************************************************************
* Shell script for creating Objective-C frameworks for iOS *
************************************************************
Written by Samuel DÃ©fago, inspired by Pete Goodliffe's article published on accu.org:
   http://accu.org/index.php/articles/1594
   
   
1) Introduction
   ------------
Xcode offers a framework creation project template for MacOS applications, but no such template
is provided for iOS. One of the reasons is probably that a framework is an NSBundle, of which
no other instance than the main bundle can exist on iOS. The stems from the fact that an NSBundle
must contain executable code, otherwise it cannot be loaded (and therefore its resources cannot be
accessed). Since iOS applications run in sandboxes, they are not allowed to use shared libraries,
and therefore bundles cannot be loaded. Thus, for applications running on iOS, there is
no way to load something like a framework (in the Xcode sense). No corresponding template is therefore
provided.

But still one should have a way of reusing library code. And in fact there is one, since Xcode 
provides a static library project template, with which static library files can be created. But
working with them has some drawbacks:
  - you can only link with one .a at once. How do you manage multiple architectures each
    with its .a file?
  - header files for the library must be provided separately and included into the client
    project
  - resources must also be provided separately
Usually, to avoid these drawbacks, projects directly import the source code of a library
into their own source code (either as a link, but often files are directly cloned as well). But
this does not work well either:
  - there is a strong likelihood that the programmer is tempted to change the library source
    code directly within her project
  - the number of source files to be compiled increases. Often, programmers just delete those
    source files they are not interested in, but this is not really convenient (moreover,
    when the library is updated, the set of source code files required may change)
  - frameworks whose source code is private cannot be used this way
    
Though there is no way to build a framework around a static library using an Xcode template, it 
is still possible to package binaries, headers and resources for easier reuse. This is just 
what make-fmwk is made for.


2) How the script works and why it works that way
   ----------------------------------------------
When a standard .framework directory (created using the Xcode template for MacOS) is added 
to Xcode, two things happen:
  - Xcode looks for a dynamic library file located at the root of this directory, and 
    bearing the same name as the .framework
  - Xcode also looks for a "Headers" directory containing the headers defining the framework
    public interface. These can then be imported by clients using
      #import <framework_name/header_name.h>
More precisely, the structure of a MacOS framework is made of symbolic links and directories
to handle various versions of a library within the same .framework directory. Refer to the
MacOS framework programming guide for more information.
      
Frameworks satisfying these requirements can be added to an Xcode project with a single click.
Such .frameworks can also embed resources since the .framework (whether it is deployed 
system-wide or copied for private use in the application bundle) is a true NSBundle.

The binary file located at the root of the .framework directory does not need to be diretctly
executable, though. It can also be a universal binary file, created by the lipo command which
brings together binaries compiled for different architectures. The linker then just figures
out which .a it needs when a project is compiled, and extracts it from the universal
binary file. Therefore, it is possible to create "fake" frameworks wrapping a static
library. Though these frameworks are not frameworks in the Xcode sense, Xcode will happily
deal with them and discover their content. Note that since static frameworks are not true frameworks 
(wrapping dynamic libraries in the MacOS sense), we do not need to create the whole directory 
structure and symbolic links needed to support different versions. Only one version will
always be available, creating such a structure would be overkill.

Based on this knowledge, the make-fwmk script creates a "static" .framework (i.e. containing a
static library) with the internal structure expected by Xcode. Such .frameworks could then be added 
using a simple drag and drop onto an Xcode project. But this does not deal with resources:
As said above, static frameworks cannot be NSBundles, therefore they cannot embed resources 
(even if we add them to a copy file target task, they will be copied into the application
bundle but never loaded at runtime; resources packed within them will never be accessible). 

To solve this problem, the .framework containing the static library is itself embedded into 
a .staticframework directory, which contains a directory for resources (and maybe other 
useful files we might need). This is this .staticframework file which is then added to an Xcode
project (read further since adding a .staticframework file requires to be careful).

The .staticframework being added to the project directly, the files it contains will be
copied at the root level of the final application bundle when the application is
assembled. In an ideal world we would have created a directory for each framework resource
files to reside in (so that resources belonging to different libraries do not overlap), but 
this does not work well because some methods (e.g. [UIImage imageWithName:] or [UIViewController 
initWithNibName:bundle:] can only look at the root level of a bundle.

Having all resources merged in the same bundle root directory means that we must strive to avoid 
name conflicts. A reasonable way to minimize the probability of conflicts is to prefix each 
resource of a library with the library name (and e.g. and underscore). The script will therefore 
display warnings if resources do not meet this requirement when a .staticframework is assembled.

The last issue to discuss is how .staticframeworks must be added to Xcode. Simply dragging and
dropping a .staticframework into a project works, but if we want the library to remain outside 
the project using it (which should be the case since both projects are independent), we must 
add a reference to it, not copy its files. This means that the path which will be stored into
the .pbxproj will depend on the machine on which the framework was added to the project. This 
becomes a nightmare when several people (and maybe a continuous integration tool) use the 
same project.

Several solutions exist:
  - store the reference to the .staticframework using a path relative to the project, and
    apply a convention like "all computers should have libraries two levels higher than
    projects in the directory hierarchy", so that relative paths are always correct
  - after getting a project, apply a tool to fix all .staticframework paths in the .pbxproj
  - be smarter :-)
The first solution is ugly and dfficult to maintain. The second solution highly depends on
the .pbxproj format and might break as it is changed. So we have no choice but to be smart.
The goal is to only store paths relative to the project in the .pbxproj. But we cannot apply
a convention, so those paths must point somewhere within the project directory itself. We 
cannot copy the framework files into the project directory, the solution is therefore to store
symbolic links instead. These symbolic links are not committed to the source code repository
and are generated using a script (link-fmwk) just after a project has been checked out on a 
computer. The script must only know for which frameworks it must generate symbolic links
and where the frameworks are located on this specific machine.

One last important remark: In your projects, always avoid absolute paths (except if pointing
at system directories). Use the cmd-I shortcut when a directory is selected in Xcode to check
that a path is relative to the project (should be the default). This way anybody will be able 
to checkout your project and use it immediately. 


3) How to create a static framework
   --------------------------------
Creating a static framework is easy:
  a) Using Xcode, create a static library project for iOS.
  b) Add files as you normally do. You can create any physical / logical structure you want.
     Whether you are creating a new project or migrating reusable code from an application
     into a library:
       - prefix all resource files (including localization files) with the name of the
         library and an underscore
       - init view controllers using initWithNibName:bundle: (with nil as bundle since no
         other bundle than the main bundle can be used on iOS), not simply using init (which
         loads a xib bearing the same name as the view controller class)
       - when accessing localized resources, use NSLocalizedStringFromTable instead of
         NSLocalizedString
  c) Create a text file listing all headers building the framework public interface,
     and which you will usually store in the project root directory
  d) Run make-fmwk.sh from the project root directory to create the bundle. Usually you
     should choose to put all .staticframeworks generated into a single "repository"
     directory (by default ~/StaticFrameworks)
In some cases additional measures are needed to be able to link against the static
framework, see section 7).
     
     
4) How to use a static framework
   -----------------------------
Using a static framework is also easy:
  a) Using Xcode, create an iOS application, or open an existing one
  b) Create a text file listing all frameworks you need, usually in the project root
     directory
  c) Locate where the .staticframework files you need are located, or create a
     repository to store them (by default the same repository as make-fwmk.sh
     will be used). If you need to compile those frameworks first, please refer to 3)
  c) Run link-fmwk.sh from your project root directory. By default link-fmwk.sh looks under
     the ~/StaticFrameworks directory, but you can change this behavior if needed. The 
     script generates symbolic links in a StaticFrameworks project subdirectory. If your 
     project is stored within a source code repository, add this directory to the locations 
     to be ignored (SVN ignore, .gitignore, etc.)
  d) Within Xcode, add the symbolic links, either using a drag and drop or a right-click
     on your project explorer tree. Add them as references only, do not copy them
  e) You can include the framework main header in your project precompiled header file,
     or just include the headers you need where you need them (always using #import < >)
     
If a static framework has been updated, you might encounter errors when compiling a project
using it. This happens in the following cases:
  - a resource has been added to or removed from the static framework
  - a source file has been added to or removed from the static framework (only if the
    source code has been packed into the framework with the -s option)
In both cases the result is that the project tree in Xcode is not in sync anymore. If files
have disappeared your project will not compile anymore, if new files have been added your
project will compile but probably not link. To fix the project tree, simply remove the
framework and add it again using the existing symbolic link.
In all other cases where the framework has been updated, compilation against the new version 
should work flawlessly.

Remark:
-------
When removing a framework, a dangling link is left in the .pbxproj file and yields
warnings when compiling the project. To avoid this issue (and to avoid having to manually
fix the .pbxproj file), the link-fmwk.sh script takes care of cleaning up dead link
for you.


5) Working on a static framework and a project using it simultaneously
   -------------------------------------------------------------------
Sometimes you are just updating a static framework when working on a project using it.
After having updated the library code, you just need to run make-fwmk.sh again
before compiling your project again.

If you need to debug your library code while executing your application, you can use
the -s option of make-fmwk to pack the source code into the static framework. This 
option should of course only be used for in-house development.


6) Working with static framework versions
   --------------------------------------
It is strongly advised to tag frameworks using the -u option. Projects using static
frameworks can then specify which framework version they are using since (by default)
the version number is appended to the .staticframework name. This way you ensure better
traceability of which tagged version of a library a project was linked with.


7) Linkage considerations
   ----------------------
Due to the highly dynamic nature of the Objective-C language, any method defined in
a library might be called, explicitly or in hidden ways (e.g. by using objc_msgSend).
Unlike C / C++, we would therefore expect the linker not to perform any dead-code
stripping for Objective-C static libraries. In some cases, though, the linker still
drops code it considers to be unused. Such code can still be referenced from an
application, though, and I ran into the following issues:
  a) Categories defined for objects not in the library: If such categories are defined
     "alone" in a source file, the linker will not load the corresponding code,
     and you will get an "Unrecognized selector" exception at runtime. This problem
     can also arise even if the category is not alone, provided the linker has no
     other reason to link with the object file it is contained in.
     For more information, refer to the following article:
        http://developer.apple.com/library/mac/#qa/qa2006/qa1490.html
  b) When using library objects in Interface Builder, you might get an "Unknown class
     <class> in Interface Builder file" error in the console at runtime. If the library
     class inherits from an existing UIKit class, your application will not crash, but
     you will not get the new functionality your class implements, leading to incorrect
     behavior.
The article mentioned above gives a solution to this problem: Double-click your client
application target under Xcode, and add the -ObjC flag to the "Other linker flags"
setting (Remark: this setting also exists when double-clicking on your project under
Xcode, but it only works when set on a target). For categories the -all_load flag must 
also be added, as explained in the article.

Adding linker flags works but is far from being optimal, though:
  - it leads to unnecessarily larger executable sizes
  - it affects all libraries which a client application is linked against
  - it has to be set manually for each client project
  - it has to be documented when you distribute a library, and you can expect users
    to forget or not set these flags correctly. Moreover, users can easily set
    parameters incorrectly for some but not all of their targets, which can lead to
    unpleasant debugging nights
As discussed above, failure to set the linker flags properly will lead to crashes (if
you are lucky) or to incorrect behaviors difficult to debug. It would therefore be nice
if linking could be forced by the library itself without any additional client
project configuration.
     
There is a solution: Fooling the linker into thinking an object file must be loaded
when linking. This is made possible by the fact that if the linker requires something
into a file, it will link all of it, even if the code in the remaining of the file
is not directly required. And since it suffices to call a method (even if this method is 
never actually itself called!) to force linking of the object file it resides in, the
solution is to add code which will be always called to each file which must always
be taken into account when linking.

To achieve this result, this script proceeds as follows:
  a) The script reads a file as input (bootstrap.txt by default), which lists all source 
     files for which linking must be forced.
  b) Each of these source files is then appended a dummy class (whose name comprises the name
     of the file to avoid clashes). Both the definitions and the declarations are added
     to the source files in order to avoid additional header files. A backup of the original 
     source file is made, and the dummy class is appended to the end of the file so that
     the original file numbers are kept intact. The dummy class itself does nothing more 
     than expose an empty class method.
  c) The library is compiled with the modified source code files, then the original files 
     are restored.
  d) A bootstrap source file is created, which repeats the dummy class definitions (since
     we have no header files for them; class definition consistency is no issue here since
     we control the whole process). A dummy function is added to call the class method for 
     all dummy classes. This file is saved into the static framework package as is.
When a static framework is then added to a project, the bootstrap code gets compiled as
well (thus the term "bootstrap" I introduced). Even if the dummy function it contains 
is not used, the linker will happily load all dummy classes since their class method is 
called, which effectively loads the modules they reside in, yielding the desire effect.
 
Remark:
When the source code is bundled into the .staticframework, no bootstrapping is needed. Since
the whole source code is available, the linking will not be as aggressive as it is when
linking to a static library. In such cases the bootstrapping file will be ignored, even if
provided.
 

8) Troubleshooting
   ---------------
a)   'I get an âUnknown class <class> in Interface Builder file" error in the console at runtime'
       or
     'I get a "selector not recognized" exception when calling a category method stemming from a
     static library'
   If your static framework contains the source code, you probably have updated your project
   and you need to remove / add the framework again, see section 4). Otherwise this means that
   some of the source files require forced linkage. If you have access to the framework
   code, update the boostrap definitions and build the framework again. Otherwise add the -ObjC
   (and maybe -all_load) flag to your project target(s) and start the build again.
   
          
9) Version history
   ---------------
1.0         September 2010          Initial release
1.1         October 2010            Convention over configuration philosophy. Easier to use
1.2         October 2010            Ability to force link for specific files. Other minor
                                    improvements
                                    
10) Planned changes
    ---------------
The 2.0 version should be even easier to use: A single command to link and build, and a single 
pom.xml-like configuration file with everything properly setup (version, repositories, etc.). 
It would definitely make sense to use Maven (and we could then benefit from artifact repositories
as well), but I don't know if it would be hard to achieve or not. This remains to be investigated.

This single pom.xml-like file should also be used to flag files which must not be copied as
resources into the framework (e.g. readme files, compilation scripts, etc.). Currently this
is not possible, any file which is not source code will be copied into the Resources folder.

Some projects alter the default output directory for binary products (e.g. CorePlot), which means
that the lipo command call fails (the script assumes a specific directory name and cannot find
the binaries). Fix.
