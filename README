************************************************************
* Shell script for creating Objective-C frameworks for iOS *
************************************************************
Written by Samuel DÃ©fago, inspired by Pete Goodliffe's article published on accu.org:
   http://accu.org/index.php/articles/1594
   
1) Introduction
   ------------
Xcode offers a framework creation project template for MacOS applications, but no such template
is provided for iOS. One of the reasons is probably that a framework is an NSBundle, of which
no other instance than the main bundle can exist on iOS. The stems from the fact that an NSBundle
must contain executable code, otherwise it cannot be loaded (and therefore its resources cannot be
accessed). Since iOS applications run in sandboxes, they are not allowed to use shared libraries,
and therefore bundles cannot be loaded. Thus, for applications running on iOS, there is
no way to load something like a framework (in the Xcode sense). No corresponding template is therefore
provided.

But still one should have a way of reusing library code. And in fact there is one, since Xcode 
provides a static library project template, with which static library files can be created. But
working with them has some drawbacks:
  - you can only link with one .a at once. How do you manage multiple architectures each
    with its .a file?
  - header files for the library must be provided separately and included into the client
    project
  - resources must also be provided separately
Usually, to avoid these drawbacks, projects directly import the source code of a library
into their own source code (either as a link, but often files are directly cloned as well). But
this does not work well either:
  - there is a strong likelihood that the programmer is tempted to change the library source
    code directly within her project
  - the number of source files to be compiled increases. Often, programmers just delete those
    source files they are not interested in, but this is not really convenient (moreover,
    when the library is updated, the set of source code files required may change)
  - frameworks whose source code is private cannot be used this way
    
Though there is no way to build a framework around a static library using an Xcode template, it 
is still possible to package binaries, headers and resources for easier reuse. This is just 
what make-fmwk is made for.


2) How the script works and why it works that way
   ----------------------------------------------
When a standard .framework directory (created using the Xcode template for MacOS) is added 
to Xcode, two things happen:
  - Xcode looks for a dynamic library file located at the root of this directory, and 
    bearing the same name as the .framework
  - Xcode also looks for a "Headers" directory containing the headers defining the framework
    public interface. These can then be imported by clients using
      #import <framework_name/header_name.h>
More precisely, the structure of a MacOS framework is made of symbolic links and directories
to handle various versions of a library within the same .framework directory. Refer to the
MacOS framework programming guide for more information.
      
Frameworks satisfying these requirements can be added to an Xcode project with a single click.
Such .frameworks can also embed resources since the .framework (whether it is deployed 
system-wide or copied for private use in the application bundle) is a true NSBundle.

The binary file located at the root of the .framework directory does not need to be diretctly
executable, though. It can also be a universal binary file, created by the lipo command which
brings together binaries compiled for different architectures. The linker then just figures
out which .a it needs when a project is compiled, and extracts it from the universal
binary file. Therefore, it is possible to create "fake" frameworks wrapping a static
library. Though these frameworks are not frameworks in the Xcode sense, Xcode will happily
deal with them and discover their content. Note that since static frameworks are not true frameworks 
(wrapping dynamic libraries in the MacOS sense), we do not need to create the whole directory 
structure and symbolic links needed to support different versions. Only one version will
always be available, creating such a structure would be overkill.

Based on this knowledge, the make-fwmk script creates a "static" .framework (i.e. containing a
static library) with the internal structure expected by Xcode. Such .frameworks could then be added 
using a simple drag and drop onto an Xcode project. But this does not deal with resources:
As said above, static frameworks cannot be NSBundles, therefore they cannot embed resources 
(even if we add them to a copy file target task, they will be copied into the application
bundle but never loaded at runtime; resources packed within them will never be accessible). 

To solve this problem, the .framework containing the static library is itself embedded into 
a .staticframework directory, which contains a directory for resources (and maybe other 
useful files we might need). This is this .staticframework file which is then added to an Xcode
project (read further since adding a .staticframework file requires to be careful).

The .staticframework being added to the project directly, the files it contains will be
copied at the root level of the final application bundle when the application is
assembled. In an ideal world we would have created a directory for each framework resource
files to reside in (so that resources belonging to different libraries do not overlap), but 
this does not work well because some methods (e.g. [UIImage imageWithName:] or [UIViewController 
initWithNibName:bundle:] can only look at the root level of a bundle.

Having all resources merged in the same bundle root directory means that we must strive to avoid 
name conflicts. A reasonable way to minimize the probability of conflicts is to prefix each 
resource of a library with the library name (and e.g. and underscore). The script will therefore 
display warnings if resources do not meet this requirement when a .staticframework is assembled.

The last issue to discuss is how .staticframeworks must be added to Xcode. Simply dragging and
dropping a .staticframework into a project works, but if we want the library to remain outside 
the project using it (which should be the case since both projects are independent), we must 
add a reference to it, not copy its files. This means that the path which will be stored into
the .pbxproj will depend on the machine on which the framework was added to the project. This 
becomes a nightmare when several people (and maybe a continuous integration tool) use the 
same project.

Several solutions exist:
  - store the reference to the .staticframework using a path relative to the project, and
    apply a convention like "all computers should have libraries two levels higher than
    projects in the directory hierarchy", so that relative paths are always correct
  - after getting a project, apply a tool to fix all .staticframework paths in the .pbxproj
  - be smarter :-)
The first solution is ugly and dfficult to maintain. The second solution highly depends on
the .pbxproj format and might break as it is changed. So we have no choice but to be smart.
The goal is to only store paths relative to the project in the .pbxproj. But we cannot apply
a convention, so those paths must point somewhere within the project directory itself. We 
cannot copy the framework files into the project directory, the solution is theefore to store
symbolic links instead. These symbolic links are not committed to the source code repository
and are generated using a script (link-fmwk) just after a project has been checked out on a 
computer. The script must only know for which frameworks it must generate symbolic links
and where the frameworks are located on this specific machine.

One last important remark: In your projects, always avoid absolute paths (except if pointing
at system directories). Use the cmd-I shortcut when a directory is selected in Xcode to check
that a path is relative to the project (should be the default). This way anybody will be able 
to checkout your project and use it immediately. 


3) How to create a static framework
   --------------------------------
Creating a static framework is easy:
  a) Using Xcode, create a static library project for iOS.
  b) Add files as you normally do. You can create any physical / logical structure you want.
     Whether you are creating a new project or migrating reusable code from an application
     into a library:
       - prefix all resource files (including localization files) with the name of the
         library and an underscore
       - init view controllers using initWithNibName:bundle: (with nil as bundle since no
         other bundle than the main bundle can be used on iOS), not simply using init (which
         loads a xib bearing the same name as the view controller class)
       - when accessing localized resources, use NSLocalizedStringFromTable instead of
         NSLocalizedString
  c) Create a text file listing all headers building the framework public interface,
     and which you will usually store in the project root directory
  d) Run make-fmwk.sh from the project root directory to create the bundle. Usually you
     should choose to put all .staticframeworks generated into a single "repository"
     directory (by default ~/StaticFrameworks)
     
     
4) How to use a static framework
   -----------------------------
Using a static framework is also easy:
  a) Using Xcode, create an iOS application, or open an existing one
  b) Create a text file listing all frameworks you need, usually in the project root
     directory
  c) Locate where the .staticframework files you need are located, or create a
     repository to store them (by default the same repository as make-fwmk.sh
     will be used). If you need to compile those frameworks first, please refer to 3)
  c) Run link-fmwk.sh from your project root directory. By default link-fmwk.sh looks under
     the ~/StaticFrameworks directory, but you can change this behavior if needed. The 
     script generates symbolic links in a StaticFrameworks project subdirectory. If your 
     project is stored within a source code repository, add this directory to the locations 
     to be ignored (SVN ignore, .gitignore, etc.)
  d) Within Xcode, add the symbolic links, either using a drag and drop or a right-click
     on your project explorer tree. Add them as references only, do not copy them
  e) You can include the framework main header in your project precompiled header file,
     or just include the headers you need where you need them (always using #import < >)
     
If a static framework has been updated, you might encounter errors when compiling a project
using it. This happens in the following cases:
  - a resource has been added to or removed from the static framework
  - a source file has been added to or removed from the static framework (only if the
    source code has been packed into the framework with the -s option)
In such cases you will need to remove the framework and add it again using the existing
symbolic link. In all other cases where the framework has been updated, compilation
against the new version should work flawlessly.


5) Working on a static framework and a project using it simultaneously
   -------------------------------------------------------------------
Sometimes you are just updating a static framework when working on a project using it.
After having updated the library code, you just need to run make-fwmk.sh again
(saving the resulting .staticframework in your static framework repository by using
the -o option). You can then simply build and link your client project again.

If you need to debug your library code while executing your application, you can
use the -s option of make-fmwk to pack the source code into the static framework.
This option should of course not be used when clients must not care about the
library implementation (which is almost always what you want).

If the framework is changing fast, you might have to link it again with your project,
see 4).


6) Working with static framework versions
   --------------------------------------
It is strongly advised to tag frameworks using the -u option. Projects using static
frameworks can then specify which framework version they are using since (by default)
the version number is appended to the .staticframework name. This way you ensure better
traceability of which tagged version of a library a project was linked with.


7) Issues
   ------
Two issues remain and must still be investigated:
  a) Due to its highly dynamic nature, the linker cannot decide what needs to be linked
     with in a library and which parts can be omitted. Therefore there is no dead-code stripping
     for Objective-C static libraries. This means that even if you use only a small subset
     of a library you will still link all of it. Two solutions can be considered:
       - use a set of preprocessor flags to disable subsets of a library when compiling it
         (this is the approach taken by Google's Objective-C libraries)
       - break down a fat library into smaller libraries (e.g. core, networking, logging,
         etc.)
  b) There is an issue with categories extending objects external to the library. The -objC 
     linker flag should be used, but I encountered some issues during my tests. I may have
     made a mistake since I did not investigate this issue long enough:
       http://developer.apple.com/library/mac/#qa/qa2006/qa1490.html
       
       
8) Version history
   ---------------
1.0         September 2010          Initial release
1.1         October 2010            Convention over configuration philosophy. Easier to use